<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VL53L0X Live Plot + MA + x/v/a</title>
<link rel="icon" href="data:,">
<style>
  :root { --gap:10px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:16px; }
  h1 { margin:0 0 12px; font-size:26px; }
  .toolbar { display:flex; flex-wrap:wrap; align-items:center; gap:var(--gap); margin-bottom:var(--gap); }
  .toolbar button, .toolbar input { padding:6px 10px; }
  #status { font-weight:700; }
  .grid { display:grid; grid-template-columns: 1fr 360px; gap:12px; align-items:start; }
  .box { border:1px solid #e5e7eb; border-radius:8px; padding:10px; }
  #chartWrap { width:100%; height:520px; }
  canvas { width:100% !important; height:100% !important; }
  #log { height:180px; overflow:auto; background:#fafafa; font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre; }
  .kv { font-size:13px; line-height:1.5; }
  .kv span { display:inline-block; min-width:150px; color:#334155; }
  .badge { display:inline-block; padding:2px 6px; border-radius:6px; font-size:12px; }
  .ok { background:#e6ffed; color:#065f46; border:1px solid #bbf7d0; }
  .ng { background:#fee2e2; color:#991b1b; border:1px solid #fecaca; }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
</head>
<body>
  <h1>VL53L0X Live Plot</h1>

  <div class="toolbar">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect">Disconnect</button>
    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
    <button id="btnReset">Reset</button>

    <!-- 表示切替 -->
    View:
    <button id="btnViewX">x–t</button>
    <button id="btnViewV">v–t</button>
    <button id="btnViewA">a–t</button>

    <!-- CSV -->
    <button id="btnCsv">CSV x–t</button>
    <button id="btnCsvV">CSV v–t</button>
    <button id="btnCsvA">CSV a–t</button>

    <label>MA N:
      <input id="maN" type="number" min="1" max="31" step="1" value="5" style="width:70px">
    </label>
    <span id="status">DISCONNECTED</span>
  </div>

  <div class="grid">
    <div id="chartWrap" class="box"><canvas id="chart"></canvas></div>
    <div class="box">
      <div class="kv"><span>Browser:</span><b id="bName">—</b></div>
      <div class="kv"><span>Secure context:</span><span id="bSecure" class="badge">—</span></div>
      <div class="kv"><span>Web Serial API:</span><span id="bSerial" class="badge">—</span></div>
      <div class="kv"><span>Top-level page:</span><span id="bTop" class="badge">—</span></div>
      <div class="kv"><span>Ports (granted):</span><b id="bPorts">—</b></div>
      <hr/>
      <div class="kv"><span>MA window (N):</span><b id="maNView">5</b></div>
      <div class="kv"><span>Est. delay:</span><b id="maDelay">—</b> ms</div>
      <div class="kv"><span>Receive rate:</span><b id="rxHz">0</b> Hz</div>
      <div class="kv"><span>Last raw:</span><b id="lastRaw">—</b> mm</div>
      <div class="kv"><span>Last filtered:</span><b id="lastFilt">—</b> mm</div>
      <div class="kv"><span>Records:</span><b id="recCount">0</b></div>
      <div id="log"></div>
    </div>
  </div>

<script>
(() => {
  // ===== Env diagnostics =====
  const $ = id => document.getElementById(id);
  const bName = $('bName'), bSecure = $('bSecure'), bSerial = $('bSerial'), bTop = $('bTop'), bPorts = $('bPorts');
  const statusEl = $('status'), rxHzEl = $('rxHz'), lastRawEl = $('lastRaw'), lastFiltEl = $('lastFilt'), maDelayEl = $('maDelay'), recCountEl = $('recCount'), logEl = $('log');

  function badge(el, ok) {
    el.className = 'badge ' + (ok ? 'ok' : 'ng');
    el.textContent = ok ? 'OK' : 'NG';
  }
  bName.textContent = navigator.userAgent;
  badge(bSecure, window.isSecureContext);
  badge(bSerial, 'serial' in navigator);
  const isTop = (window.top === window.self);
  badge(bTop, isTop);

  async function updateGrantedPorts() {
    if (!('serial' in navigator)) { bPorts.textContent = '—'; return; }
    try {
      const ports = await navigator.serial.getPorts();
      bPorts.textContent = String(ports.length);
    } catch {
      bPorts.textContent = 'error';
    }
  }
  updateGrantedPorts();

  function log(s){ logEl.textContent += s + '\n'; logEl.scrollTop = logEl.scrollHeight; }

  // ===== Chart =====
  const ctx = document.getElementById('chart');
  const data = { labels: [], datasets: [{ label:'Distance [mm] (filtered)', data: [], tension:0, pointRadius:0, parsing:false }]};
  const chart = new Chart(ctx, {
    type: 'line',
    data,
    options: {
      animation: false,
      responsive: true,
      normalized: true,
      scales: {
        x: { type:'linear', title:{display:true, text:'Time [s]'}, min:0, max:10 },
        y: { beginAtZero:true, title:{display:true, text:'Distance [mm]'}, suggestedMax:1000 }
      },
      plugins: { legend:{ display:false } }
    }
  });

  let xWindow = 10;
  function pushPoint(tSec, y) {
    if (!Number.isFinite(y)) return;
    data.datasets[0].data.push({ x:tSec, y });
    const sMax = chart.options.scales.y.suggestedMax ?? 1000;
    if (y > sMax) chart.options.scales.y.suggestedMax = Math.ceil(y / 200) * 200;
    if (tSec > xWindow) {
      xWindow = Math.ceil(tSec / 10) * 10;
      chart.options.scales.x.max = xWindow;
    }
    requestUpdate();
  }
  let rafId=null, needs=false;
  function requestUpdate() {
    if (rafId) { needs=true; return; }
    rafId = requestAnimationFrame(() => { chart.update('none'); rafId=null; if (needs){ needs=false; requestUpdate(); }});
  }

  // ===== Moving Average =====
  const maNInput = $('maN');
  const maNView  = $('maNView');
  let MA_N = 5;
  const maBuf = []; let maSum = 0;
  function resetMA(){ maBuf.length=0; maSum=0; }
  function setMAN(n){
    MA_N = Math.max(1, Math.min(31, Math.floor(n||1)));
    maNInput.value = MA_N; maNView.textContent = String(MA_N);
    resetMA(); updateDelayEstimate();
    // 窓を変えたら表示再構築（v/aも影響）
    rebuildSeries();
  }
  setMAN(Number(maNInput.value) || 5);
  maNInput.addEventListener('change', () => setMAN(maNInput.value));
  maNInput.addEventListener('input',  () => setMAN(maNInput.value));
  function maFilter(x){
    if (MA_N <= 1) return x; // N=1 は生データ
    maBuf.push(x); maSum += x;
    if (maBuf.length > MA_N) maSum -= maBuf.shift();
    if (maBuf.length < MA_N) return null;
    return maSum / MA_N;
  }
  function updateDelayEstimate(){
    const hz = parseFloat(rxHzEl.textContent) || 0;
    if (!hz) { maDelayEl.textContent = '—'; return; }
    const delay_ms = ((MA_N - 1) / (2 * hz)) * 1000;
    maDelayEl.textContent = String(Math.round(delay_ms));
  }

  // ===== Records & derived series =====
  // mm_filtered は小数のまま保存（微分精度のため）。CSV出力時に丸めます。
  const records = []; // {t, mm_raw, mm_filtered}

  function seriesX(){
    return records.map(r => ({ t: r.t, y: r.mm_filtered }));
  }
  // 不等間隔対応・中央差分（端点は片側差分）
  function seriesV(){
    const n = records.length; if (n < 2) return [];
    const out = [];
    for (let i=0;i<n;i++){
      let v=null;
      if (i>0 && i<n-1){
        const t0=records[i-1].t/1000, t2=records[i+1].t/1000;
        const x0=records[i-1].mm_filtered, x2=records[i+1].mm_filtered;
        const dt=t2-t0; if (dt>0) v=(x2-x0)/dt; // mm/s
      } else if (i===0){
        const dt=(records[1].t-records[0].t)/1000;
        if (dt>0) v=(records[1].mm_filtered-records[0].mm_filtered)/dt;
      } else {
        const dt=(records[i].t-records[i-1].t)/1000;
        if (dt>0) v=(records[i].mm_filtered-records[i-1].mm_filtered)/dt;
      }
      if (v!=null && isFinite(v)) out.push({ t: records[i].t, y: v });
    }
    return out;
  }
  // a = 2*((x2-x1)/dt12 - (x1-x0)/dt01) / (t2-t0)
  function seriesA(){
    const n = records.length; if (n < 3) return [];
    const out = [];
    for (let i=1;i<n-1;i++){
      const t0=records[i-1].t/1000, t1=records[i].t/1000, t2=records[i+1].t/1000;
      const x0=records[i-1].mm_filtered, x1=records[i].mm_filtered, x2=records[i+1].mm_filtered;
      const dt01=t1-t0, dt12=t2-t1, dt02=t2-t0;
      if (dt01<=0 || dt12<=0 || dt02<=0) continue;
      const a = 2 * ( (x2-x1)/dt12 - (x1-x0)/dt01 ) / dt02; // mm/s^2
      if (isFinite(a)) out.push({ t: records[i].t, y: a });
    }
    return out;
  }

  // ===== View handling =====
  let currentView = 'x'; // 'x' | 'v' | 'a'
  function setView(v){
    currentView = v;
    if (v==='x'){
      chart.options.scales.y.beginAtZero = true;
      chart.options.scales.y.title.text = 'Distance [mm]';
      chart.options.scales.y.suggestedMax = 1000;
    } else {
      chart.options.scales.y.beginAtZero = false;
      chart.options.scales.y.title.text = (v==='v') ? 'Velocity [mm/s]' : 'Acceleration [mm/s²]';
      // 対称レンジに近い suggestedMin/Max を設定（後でオート拡張）
      chart.options.scales.y.suggestedMin = -1000;
      chart.options.scales.y.suggestedMax = 1000;
    }
    rebuildSeries();
  }
  function autoscaleForSeries(ser, step){
    if (!ser.length) return;
    let maxAbs = 0;
    for (const p of ser) { const a = Math.abs(p.y); if (a > maxAbs) maxAbs = a; }
    if (maxAbs === 0) return;
    const target = Math.ceil(maxAbs / step) * step;
    if (currentView==='x'){
      chart.options.scales.y.suggestedMax = Math.max(chart.options.scales.y.suggestedMax ?? step, target);
    } else {
      chart.options.scales.y.suggestedMax = target;
      chart.options.scales.y.suggestedMin = -target;
    }
  }
  function rebuildSeries(){
    let ser;
    if (currentView==='x') {
      ser = seriesX();
      data.datasets[0].label = 'Distance [mm] (filtered)';
      data.datasets[0].data = ser.map(p => ({ x: p.t/1000, y: p.y }));
      autoscaleForSeries(ser, 200);
    } else if (currentView==='v') {
      ser = seriesV();
      data.datasets[0].label = 'Velocity [mm/s]';
      data.datasets[0].data = ser.map(p => ({ x: p.t/1000, y: p.y }));
      autoscaleForSeries(ser, 200);
    } else {
      ser = seriesA();
      data.datasets[0].label = 'Acceleration [mm/s²]';
      data.datasets[0].data = ser.map(p => ({ x: p.t/1000, y: p.y }));
      autoscaleForSeries(ser, 500);
    }
    const lastT = ser.length ? ser[ser.length-1].t/1000 : 0;
    xWindow = Math.max(10, Math.ceil(lastT/10)*10);
    chart.options.scales.x.max = xWindow;
    requestUpdate();
  }
  setView('x');

  // ===== CSV =====
  function downloadCsvX(){
    if (!records.length) return;
    const header = 't_ms,mm_raw,mm_filtered,cm_filtered\n';
    const body = records.map(r => `${r.t},${Math.round(r.mm_raw)},${Math.round(r.mm_filtered)},${(r.mm_filtered/10).toFixed(1)}`).join('\n')+'\n';
    triggerCsv(header+body, 'xt.csv');
  }
  function downloadCsvV(){
    const s = seriesV(); if (!s.length) return;
    const header = 't_ms,vel_mm_per_s,vel_cm_per_s\n';
    const body = s.map(p => `${p.t},${p.y.toFixed(3)},${(p.y/10).toFixed(3)}`).join('\n')+'\n';
    triggerCsv(header+body, 'vt.csv');
  }
  function downloadCsvA(){
    const s = seriesA(); if (!s.length) return;
    const header = 't_ms,acc_mm_per_s2,acc_m_per_s2\n';
    const body = s.map(p => `${p.t},${p.y.toFixed(3)},${(p.y/1000).toFixed(6)}`).join('\n')+'\n';
    triggerCsv(header+body, 'at.csv');
  }
  function triggerCsv(text, filename){
    const blob = new Blob([text], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  // ===== Serial plumbing（元のまま） =====
  let port=null, reader=null, reading=false;
  let streaming=false; let t0=0;
  let rxTimes=[];

  async function startReading() {
    const textDecoder = new TextDecoderStream();
    port.readable.pipeTo(textDecoder.writable).catch(()=>{});
    reader = textDecoder.readable.getReader();
    let buf=''; reading=true;
    log('[reader] started');
    while (reading) {
      let chunk;
      try { chunk = await reader.read(); } catch(e){ log('[reader] error: '+e); break; }
      if (!chunk || chunk.done) break;
      const value = chunk.value; if (!value) continue;
      buf += value;
      let idx;
      while ((idx = buf.indexOf('\n')) >= 0) {
        const line = buf.slice(0, idx).replace(/\r$/, '').trim();
        buf = buf.slice(idx+1);
        handleLine(line);
      }
    }
    log('[reader] stopped');
  }

  function handleLine(line){
    if (!line) return;
    if (line.includes('TIMEOUT')) { log('[skip] TIMEOUT'); return; }
    const m = line.match(/-?\d{1,6}/);
    if (!m) { return; }
    const mmRaw = parseInt(m[0],10);
    lastRawEl.textContent = String(mmRaw);

    const now = performance.now();
    rxTimes.push(now);
    while (rxTimes.length && now - rxTimes[0] > 1000) rxTimes.shift();
    rxHzEl.textContent = String(rxTimes.length);
    updateDelayEstimate();

    if (!streaming) return;
    if (!t0) t0 = now;
    const t_ms = Math.round(now - t0);

    const y = maFilter(mmRaw);
    if (y == null) return;
    lastFiltEl.textContent = String(Math.round(y));
    records.push({ t: t_ms, mm_raw: mmRaw, mm_filtered: y });
    recCountEl.textContent = String(records.length);

    // 表示中のビューに応じて更新方法を変更
    if (currentView === 'x') {
      pushPoint(t_ms/1000, y);   // x–tは従来通り1点追加で高速
    } else {
      rebuildSeries();           // v/aは中央差分のため都度再計算
    }
  }

  // ===== Buttons =====
  $('btnConnect').addEventListener('click', async () => {
    if (!window.isSecureContext) { alert('このページは HTTPS か localhost で開いてください（file:// は不可）。'); log('[connect] insecure context'); return; }
    if (!('serial' in navigator)) { alert('Web Serial未対応です。Chrome/Edge(デスクトップ)で開いてください。'); log('[connect] no navigator.serial'); return; }
    try {
      const p = await navigator.serial.requestPort();
      await p.open({ baudRate: 9600 }); // 例スケッチ
      port = p;
      statusEl.textContent = 'CONNECTED';
      log('[open] ok 9600bps');
      streaming = true; t0=0; resetMA(); records.length=0; recCountEl.textContent='0';
      // 表示をクリア
      data.datasets[0].data.length = 0; chart.options.scales.x.max = 10; xWindow = 10; requestUpdate();
      startReading();
      updateGrantedPorts();
    } catch (e) {
      if (e && e.name === 'NotFoundError') { log('[connect] user canceled port picker'); }
      else { alert('Serial接続に失敗: ' + (e && (e.message || e.name))); log('[connect] error: ' + e); }
    }
  });

  $('btnDisconnect').addEventListener('click', async () => {
    streaming=false; reading=false;
    try { if (reader) await reader.cancel(); } catch {}
    try { if (reader) { reader.releaseLock(); reader=null; } } catch {}
    try { if (port) await port.close(); } catch {}
    port=null; statusEl.textContent='DISCONNECTED'; log('[close] done');
  });

  $('btnStart').addEventListener('click', () => {
    if (!port) { alert('先にConnectしてください'); return; }
    streaming = true; t0=0; resetMA(); statusEl.textContent='STREAMING'; log('[stream] start');
  });
  $('btnStop').addEventListener('click', () => {
    streaming = false; statusEl.textContent='STOPPED'; log('[stream] stop');
  });
  $('btnReset').addEventListener('click', () => {
    streaming=false;
    data.datasets[0].data.length=0;
    records.length=0; recCountEl.textContent='0';
    chart.options.scales.x.min=0; chart.options.scales.x.max=10;
    // ビュー別の初期Yレンジ
    if (currentView==='x'){ chart.options.scales.y.beginAtZero=true; chart.options.scales.y.suggestedMax=1000; }
    else{ chart.options.scales.y.beginAtZero=false; chart.options.scales.y.suggestedMin=-1000; chart.options.scales.y.suggestedMax=1000; }
    xWindow=10; chart.update('none'); t0=0;
    lastRawEl.textContent='—'; lastFiltEl.textContent='—'; rxHzEl.textContent='0'; maDelayEl.textContent='—';
    resetMA(); log('[reset] ui cleared'); statusEl.textContent='RESET';
  });

  // 既存の x–t CSV（互換）
  $('btnCsv').addEventListener('click', () => downloadCsvX());
  // 追加：v–t / a–t CSV
  $('btnCsvV').addEventListener('click', () => downloadCsvV());
  $('btnCsvA').addEventListener('click', () => downloadCsvA());

  // View切り替え
  $('btnViewX').addEventListener('click', () => setView('x'));
  $('btnViewV').addEventListener('click', () => setView('v'));
  $('btnViewA').addEventListener('click', () => setView('a'));
})();
</script>
</body>
</html>
