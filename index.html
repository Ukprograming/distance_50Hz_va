<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VL53L0X Live Plot + MA + x/v/a (safe)</title>
<link rel="icon" href="data:,">
<!-- Chart.js はCDN障害でも落ちないよう defer で読み込み、未ロード時はノーグラフで動作 -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4" defer></script>
<style>
  :root { --gap:10px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:16px; }
  h1 { margin:0 0 12px; font-size:26px; }
  .toolbar { display:flex; flex-wrap:wrap; align-items:center; gap:var(--gap); margin-bottom:var(--gap); }
  .toolbar button, .toolbar input { padding:6px 10px; }
  #status { font-weight:700; }
  .grid { display:grid; grid-template-columns: 1fr 360px; gap:12px; align-items:start; }
  .box { border:1px solid #e5e7eb; border-radius:8px; padding:10px; }
  #chartWrap { width:100%; height:520px; display:grid; place-items:center; color:#64748b; }
  canvas { width:100% !important; height:100% !important; display:none; }
  #log { height:180px; overflow:auto; background:#fafafa; font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre; }
  .kv { font-size:13px; line-height:1.5; }
  .kv span { display:inline-block; min-width:150px; color:#334155; }
  .badge { display:inline-block; padding:2px 6px; border-radius:6px; font-size:12px; }
  .ok { background:#e6ffed; color:#065f46; border:1px solid #bbf7d0; }
  .ng { background:#fee2e2; color:#991b1b; border:1px solid #fecaca; }
  .pill { padding:2px 8px; border-radius:999px; border:1px solid #cbd5e1; font-size:12px; }
</style>

<!-- どこで止まってもLogに出す“早期ロガー” -->
<script>
  (function(){
    const q=[]; window.logEarly = s => { q.push(s); const el=document.getElementById('log'); if(el){ while(q.length){ el.textContent += q.shift()+'\n'; el.scrollTop=el.scrollHeight; } } console.log(s); };
    window.addEventListener('error', e => logEarly('[js error] '+(e?.message||e)));
    window.addEventListener('unhandledrejection', e => logEarly('[promise rej] '+(e?.reason?.message||e?.reason)));
  })();
</script>
</head>
<body>
  <h1>VL53L0X Live Plot</h1>

  <div class="toolbar">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect">Disconnect</button>
    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
    <button id="btnReset">Reset</button>

    <!-- 表示切替 -->
    View:
    <button id="btnViewX">x–t</button>
    <button id="btnViewV">v–t</button>
    <button id="btnViewA">a–t</button>

    <!-- CSV -->
    <button id="btnCsv">CSV x–t</button>
    <button id="btnCsvV">CSV v–t</button>
    <button id="btnCsvA">CSV a–t</button>

    <label>MA N:
      <input id="maN" type="number" min="1" max="31" step="1" value="5" style="width:70px">
    </label>
    <span id="status">DISCONNECTED</span>
  </div>

  <div class="grid">
    <div id="chartWrap" class="box">
      <canvas id="chart"></canvas>
      <div id="noChart">（Chart.js未ロードでも受信・CSVは動作します）</div>
    </div>
    <div class="box">
      <div class="kv"><span>Browser:</span><b id="bName">—</b></div>
      <div class="kv"><span>Secure context:</span><span id="bSecure" class="badge">—</span></div>
      <div class="kv"><span>Web Serial API:</span><span id="bSerial" class="badge">—</span></div>
      <div class="kv"><span>Top-level page:</span><span id="bTop" class="badge">—</span></div>
      <div class="kv"><span>Ports (granted):</span><b id="bPorts">—</b></div>
      <hr/>
      <div class="kv"><span>MA window (N):</span><b id="maNView">5</b></div>
      <div class="kv"><span>Est. delay:</span><b id="maDelay">—</b> ms</div>
      <div class="kv"><span>Receive rate:</span><b id="rxHz">0</b> Hz</div>
      <div class="kv"><span>Last raw:</span><b id="lastRaw">—</b> mm</div>
      <div class="kv"><span>Last filtered:</span><b id="lastFilt">—</b> mm</div>
      <div class="kv"><span>Records:</span><b id="recCount">0</b></div>
      <div id="log"></div>
    </div>
  </div>

<script>
(() => {
  const $ = id => document.getElementById(id);
  const log = s => { logEarly(s); }; // 早期ロガーに合流

  // ===== Env diagnostics =====
  const bName=$('bName'), bSecure=$('bSecure'), bSerial=$('bSerial'), bTop=$('bTop'), bPorts=$('bPorts');
  const statusEl=$('status'), rxHzEl=$('rxHz'), lastRawEl=$('lastRaw'), lastFiltEl=$('lastFilt'), maDelayEl=$('maDelay'), recCountEl=$('recCount');

  function badge(el, ok){ el.className='badge ' + (ok?'ok':'ng'); el.textContent = ok ? 'OK' : 'NG'; }
  bName.textContent = navigator.userAgent;
  badge(bSecure, window.isSecureContext);
  badge(bSerial, 'serial' in navigator);
  badge(bTop, window.top === window.self);
  (async()=>{ if(!('serial' in navigator)){ bPorts.textContent='—'; return; }
    try{ const ports=await navigator.serial.getPorts(); bPorts.textContent=String(ports.length);}catch{ bPorts.textContent='error'; }
  })();

  // ===== Chart (safe) =====
  let chart=null, chartReady=false;
  const canvas=$('chart'), noChart=$('noChart');
  function requestUpdate(){ if(!chartReady) return; if(requestUpdate._id) return; requestUpdate._id=requestAnimationFrame(()=>{ chart.update('none'); requestUpdate._id=0; }); }

  function ensureChart(){
    if (typeof Chart==='undefined') { log('[chart] not loaded → no-graph mode'); return; }
    canvas.style.display='block'; noChart.style.display='none';
    const data={labels:[],datasets:[{label:'Distance [mm] (filtered)',data:[],tension:0,pointRadius:0,parsing:false}]};
    chart=new Chart(canvas.getContext('2d'),{
      type:'line', data,
      options:{
        animation:false, responsive:true, normalized:true,
        scales:{ x:{type:'linear', title:{display:true,text:'Time [s]'},min:0,max:10},
                 y:{beginAtZero:true, title:{display:true,text:'Distance [mm]'}, suggestedMax:1000} },
        plugins:{ legend:{display:false} }
      }
    });
    chartReady=true;
    log('[chart] ready');
  }
  // DOM構築後にChart生成（deferでも万一未ロードならno-graph）
  if (document.readyState==='loading') {
    document.addEventListener('DOMContentLoaded', ensureChart);
  } else { ensureChart(); }

  // ===== Moving Average =====
  const maNInput=$('maN'), maNView=$('maNView');
  let MA_N=5; const maBuf=[]; let maSum=0;
  function resetMA(){ maBuf.length=0; maSum=0; }
  function setMAN(n){ MA_N=Math.max(1,Math.min(31,Math.floor(n||1))); maNInput.value=MA_N; maNView.textContent=String(MA_N); resetMA(); updateDelayEstimate(); rebuildSeries(); }
  function maFilter(x){ if(MA_N<=1) return x; maBuf.push(x); maSum+=x; if(maBuf.length>MA_N) maSum-=maBuf.shift(); if(maBuf.length<MA_N) return null; return maSum/MA_N; }
  function updateDelayEstimate(){ const hz=parseFloat(rxHzEl.textContent)||0; maDelayEl.textContent = hz? String(Math.round(((MA_N-1)/(2*hz))*1000)) : '—'; }
  setMAN(Number(maNInput.value)||5);
  maNInput.addEventListener('change',()=>setMAN(maNInput.value));
  maNInput.addEventListener('input', ()=>setMAN(maNInput.value));

  // ===== Records & derived series =====
  const records=[]; // {t, mm_raw, mm_filtered}
  function seriesX(){ return records.map(r=>({t:r.t, y:r.mm_filtered})); }
  function seriesV(){
    const n=records.length; if(n<2) return [];
    const out=[];
    for(let i=0;i<n;i++){
      let v=null;
      if(i>0 && i<n-1){
        const t0=records[i-1].t/1000, t2=records[i+1].t/1000;
        const x0=records[i-1].mm_filtered, x2=records[i+1].mm_filtered;
        const dt=t2-t0; if(dt>0) v=(x2-x0)/dt;
      }else if(i===0){
        const dt=(records[1].t-records[0].t)/1000; if(dt>0) v=(records[1].mm_filtered-records[0].mm_filtered)/dt;
      }else{
        const dt=(records[i].t-records[i-1].t)/1000; if(dt>0) v=(records[i].mm_filtered-records[i-1].mm_filtered)/dt;
      }
      if(v!=null && isFinite(v)) out.push({t:records[i].t, y:v});
    }
    return out;
  }
  function seriesA(){
    const n=records.length; if(n<3) return [];
    const out=[];
    for(let i=1;i<n-1;i++){
      const t0=records[i-1].t/1000, t1=records[i].t/1000, t2=records[i+1].t/1000;
      const x0=records[i-1].mm_filtered, x1=records[i].mm_filtered, x2=records[i+1].mm_filtered;
      const dt01=t1-t0, dt12=t2-t1, dt02=t2-t0;
      if(dt01<=0||dt12<=0||dt02<=0) continue;
      const a=2*((x2-x1)/dt12 - (x1-x0)/dt01)/dt02;
      if(isFinite(a)) out.push({t:records[i].t, y:a});
    }
    return out;
  }

  // ===== Chart helpers =====
  let xWindow=10;
  function pushPoint(tSec,y){
    if(!chartReady) return; if(!Number.isFinite(y)) return;
    chart.data.datasets[0].data.push({x:tSec,y});
    const sMax=chart.options.scales.y.suggestedMax??1000;
    if (chart.options.scales.y.beginAtZero && y>sMax) chart.options.scales.y.suggestedMax=Math.ceil(y/200)*200;
    if (tSec>xWindow){ xWindow=Math.ceil(tSec/10)*10; chart.options.scales.x.max=xWindow; }
    requestUpdate();
  }
  let currentView='x';
  function autoscaleForSeries(ser, step, symmetric=false){
    if(!chartReady||!ser.length) return;
    if(symmetric){
      let maxAbs=0; for(const p of ser){ const a=Math.abs(p.y); if(a>maxAbs) maxAbs=a; }
      const tgt=Math.max(step, Math.ceil(maxAbs/step)*step);
      chart.options.scales.y.suggestedMin=-tgt; chart.options.scales.y.suggestedMax=tgt;
    }else{
      let max=0; for(const p of ser){ if(p.y>max) max=p.y; }
      const tgt=Math.max(step, Math.ceil(max/step)*step);
      chart.options.scales.y.suggestedMax=tgt;
    }
  }
  function rebuildSeries(){
    if(!chartReady) return;
    let ser;
    if(currentView==='x'){
      ser=seriesX();
      chart.data.datasets[0].label='Distance [mm] (filtered)';
      chart.options.scales.y.beginAtZero=true;
      chart.options.scales.y.title.text='Distance [mm]';
      chart.options.scales.y.suggestedMin=0; chart.options.scales.y.suggestedMax=1000;
      chart.data.datasets[0].data=ser.map(p=>({x:p.t/1000,y:p.y}));
      autoscaleForSeries(ser,200,false);
    }else if(currentView==='v'){
      ser=seriesV();
      chart.data.datasets[0].label='Velocity [mm/s]';
      chart.options.scales.y.beginAtZero=false;
      chart.options.scales.y.title.text='Velocity [mm/s]';
      chart.data.datasets[0].data=ser.map(p=>({x:p.t/1000,y:p.y}));
      autoscaleForSeries(ser,200,true);
    }else{
      ser=seriesA();
      chart.data.datasets[0].label='Acceleration [mm/s²]';
      chart.options.scales.y.beginAtZero=false;
      chart.options.scales.y.title.text='Acceleration [mm/s²]';
      chart.data.datasets[0].data=ser.map(p=>({x:p.t/1000,y:p.y}));
      autoscaleForSeries(ser,500,true);
    }
    const lastT=ser.length? ser[ser.length-1].t/1000 : 0;
    xWindow=Math.max(10,Math.ceil(lastT/10)*10);
    chart.options.scales.x.max=xWindow;
    requestUpdate();
  }
  function setView(v){ currentView=v; rebuildSeries(); }

  // ===== CSV =====
  function triggerCsv(text, name){ const blob=new Blob([text],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }
  function downloadCsvX(){ if(!records.length) return; const header='t_ms,mm_raw,mm_filtered,cm_filtered\n'; const body=records.map(r=>`${r.t},${Math.round(r.mm_raw)},${Math.round(r.mm_filtered)},${(r.mm_filtered/10).toFixed(1)}`).join('\n')+'\n'; triggerCsv(header+body,'xt.csv'); }
  function downloadCsvV(){ const s=seriesV(); if(!s.length) return; const header='t_ms,vel_mm_per_s,vel_cm_per_s\n'; const body=s.map(p=>`${p.t},${p.y.toFixed(3)},${(p.y/10).toFixed(3)}`).join('\n')+'\n'; triggerCsv(header+body,'vt.csv'); }
  function downloadCsvA(){ const s=seriesA(); if(!s.length) return; const header='t_ms,acc_mm_per_s2,acc_m_per_s2\n'; const body=s.map(p=>`${p.t},${p.y.toFixed(3)},${(p.y/1000).toFixed(6)}`).join('\n')+'\n'; triggerCsv(header+body,'at.csv'); }

  // ===== Serial plumbing（堅牢） =====
  let port=null, reader=null, reading=false;
  let streaming=false, t0=0, rxTimes=[];

  async function startReading(){
    const textDecoder=new TextDecoderStream();
    port.readable.pipeTo(textDecoder.writable).catch(()=>{});
    reader=textDecoder.readable.getReader();
    let buf=''; reading=true; log('[reader] started');
    while(reading){
      let chunk; try{ chunk=await reader.read(); }catch(e){ log('[reader] error: '+(e?.message||e)); break; }
      if(!chunk || chunk.done) break;
      const value=chunk.value; if(!value) continue;
      buf+=value;
      let idx; while((idx=buf.indexOf('\n'))>=0){
        const line=buf.slice(0,idx).replace(/\r$/,'').trim(); buf=buf.slice(idx+1);
        handleLine(line);
      }
    }
    log('[reader] stopped');
  }

  function handleLine(line){
    if(!line) return;
    if(line.includes('TIMEOUT')) return;
    const m=line.match(/-?\d{1,6}/);
    if(!m) return;
    const mmRaw=parseInt(m[0],10);
    lastRawEl.textContent=String(mmRaw);

    const now=performance.now();
    rxTimes.push(now); while(rxTimes.length && now-rxTimes[0]>1000) rxTimes.shift();
    rxHzEl.textContent=String(rxTimes.length); updateDelayEstimate();

    if(!streaming) return;
    if(!t0) t0=now;
    const t_ms=Math.round(now-t0);

    const y=maFilter(mmRaw);
    if(y==null) return;

    lastFiltEl.textContent=String(Math.round(y));
    records.push({t:t_ms, mm_raw:mmRaw, mm_filtered:y});
    recCountEl.textContent=String(records.length);

    if(currentView==='x') pushPoint(t_ms/1000, y); else rebuildSeries();
  }

  // ===== Buttons（Connectは必ずLogを出す） =====
  $('btnConnect').addEventListener('click', async () => {
    log('[ui] connect clicked');
    if(!window.isSecureContext){ alert('HTTPS または localhost で開いてください（file:// は不可）。'); log('[connect] insecure context'); return; }
    if(!('serial' in navigator)){ alert('Web Serial未対応です（Chrome/Edge デスクトップ）。'); log('[connect] no navigator.serial'); return; }
    // 既存をクローズしてから
    try{ if(reader) await reader.cancel(); }catch{} try{ if(reader){ reader.releaseLock(); reader=null; } }catch{} try{ if(port) await port.close(); }catch{}
    try{
      const p=await navigator.serial.requestPort();
      await p.open({baudRate:9600});
      port=p; statusEl.textContent='CONNECTED'; log('[open] ok 9600bps');
      streaming=true; t0=0; resetMA(); records.length=0; recCountEl.textContent='0';
      if(chartReady){ chart.data.datasets[0].data.length=0; chart.options.scales.x.max=10; xWindow=10; requestUpdate(); }
      startReading();
      // Ports更新
      try{ const ports=await navigator.serial.getPorts(); bPorts.textContent=String(ports.length);}catch{}
    }catch(e){
      if(e && e.name==='NotFoundError'){ log('[connect] user canceled port picker'); }
      else{ alert('Serial接続に失敗: '+(e?.message||e)); log('[connect] error: '+(e?.message||e)); }
    }
  });

  $('btnDisconnect').addEventListener('click', async () => {
    streaming=false; reading=false;
    try{ if(reader) await reader.cancel(); }catch{}
    try{ if(reader){ reader.releaseLock(); reader=null; } }catch{}
    try{ if(port) await port.close(); }catch{}
    port=null; statusEl.textContent='DISCONNECTED'; log('[close] done');
  });

  $('btnStart').addEventListener('click', () => {
    log('[ui] start clicked');
    if(!port){ alert('先にConnectしてください'); return; }
    streaming=true; t0=0; resetMA(); statusEl.textContent='STREAMING'; log('[stream] start');
  });
  $('btnStop').addEventListener('click', () => {
    log('[ui] stop clicked');
    streaming=false; statusEl.textContent='STOPPED'; log('[stream] stop');
  });
  $('btnReset').addEventListener('click', () => {
    log('[ui] reset clicked');
    streaming=false;
    if(chartReady){
      chart.data.datasets[0].data.length=0;
      chart.options.scales.x.min=0; chart.options.scales.x.max=10;
      if(currentView==='x'){ chart.options.scales.y.beginAtZero=true; chart.options.scales.y.suggestedMin=0; chart.options.scales.y.suggestedMax=1000; }
      else { chart.options.scales.y.beginAtZero=false; chart.options.scales.y.suggestedMin=-1000; chart.options.scales.y.suggestedMax=1000; }
      requestUpdate();
    }
    records.length=0; recCountEl.textContent='0';
    lastRawEl.textContent='—'; lastFiltEl.textContent='—'; rxHzEl.textContent='0'; maDelayEl.textContent='—';
    t0=0; resetMA(); statusEl.textContent='RESET'; log('[reset] ui cleared');
  });

  $('btnViewX').addEventListener('click', ()=>{ setView('x'); });
  $('btnViewV').addEventListener('click', ()=>{ setView('v'); });
  $('btnViewA').addEventListener('click', ()=>{ setView('a'); });

  $('btnCsv').addEventListener('click', ()=>downloadCsvX());
  $('btnCsvV').addEventListener('click', ()=>downloadCsvV());
  $('btnCsvA').addEventListener('click', ()=>downloadCsvA());
})();
</script>
</body>
</html>
